/*
 * uart.c
 *
 * Created: 02.08.2016 4:04:36
 *  Author: LV
 */

#include "uart.h"
#include "math.h"

void init_UART(unsigned long baudrate)
{
	uint8_t ubrr = round(F_CPU/(16*baudrate))-1;
	//	Установка скорости UART
	UBRR0H=(uint8_t)(ubrr>>8);	//	UBRR=f/(16*baud)-1 f=8000000Гц baud=9600,
//	UBRR0L=25;	//	нормальный асинхронный двунаправленный режим работы, f=16000000Гц baud=38400, работает
//	UBRR0L=51;	//	нормальный асинхронный двунаправленный режим работы, f=16000000Гц baud=19200
//	UBRR0L=103;	//	нормальный асинхронный двунаправленный режим работы, f=16000000Гц baud=9600
	UBRR0L=(uint8_t)ubrr;	//	UBRR=f/(16*baud)-1 f=8000000Гц baud=9600,


	//			RXC			-	завершение приёма
	//			|TXC		-	завершение передачи
	//			||UDRE 		-	отсутствие данных для отправки
	//			|||FE		-	ошибка кадра
	//			||||DOR		-	ошибка переполнение буфера
	//			|||||PE		-	ошибка чётности
	//			||||||U2X	-	Двойная скорость
	//			|||||||MPCM	-	Многопроцессорный режим
	//			76543210
	UCSR0A =  0b00000000;

	//			UMSEL01		-	1 для USART
	//			|UMSEL00	-	режим:1-синхронный 0-асинхронный
	//			||UPM1		-	UPM0:1 чётность
	//			|||UPM0		-	UPM0:1 чётность
	//			||||USBS	-	стоп биты: 0-1, 1-2
	//			|||||UCSZ1	-	UCSZ0:2 размер кадра данных
	//			||||||UCSZ0	-	UCSZ0:2 размер кадра данных
	//			|||||||UCPOL-	в синхронном режиме - тактирование
	//			76543210
	UCSR0C =  0b00000110;	//	8-битовая посылка

	//			RXCIE		-	прерывание при приёме данных
	//			|TXCIE		-	прерывание при завершение передачи
	//			||UDRIE		-	прерывание отсутствие данных для отправки
	//			|||RXEN		-	разрешение приёма
	//			||||TXEN	-	разрешение передачи
	//			|||||UCSZ2	-	UCSZ0:2 размер кадра данных
	//			||||||RXB8	-	9 бит принятых данных
	//			|||||||TXB8	-	9 бит переданных данных
	//			76543210
	UCSR0B =  0b10011000;	//	разрешены приём и передача по UART, прерывание при приёме данных
}
//---------------------------------------------------------------------------------

void send_Uart(unsigned char c)		//	Отправка байта
{
	while(!(UCSR0A&(1<<UDRE0)))	{}	//	Устанавливается, когда регистр свободен

	UDR0 = c;
}
//---------------------------------------------------------------------------------

void send_Uart_str(unsigned char *s)	//	Отправка строки
{
	while (*s != 0) send_Uart(*s++);
}
//---------------------------------------------------------------------------------

void send_int_Uart(unsigned int c)		//	Отправка числа от 0000 до 9999
{
	unsigned char temp;
	c=c%10000;
	temp=c/100;
	send_Uart(temp/10+'0');
	send_Uart(temp%10+'0');
	temp=c%100;;
	send_Uart(temp/10+'0');
	send_Uart(temp%10+'0');
}
//---------------------------------------------------------------------------------

unsigned char getch_Uart(void)		//	Получение байта
{
	while(!(UCSR0A&(1<<RXC0))) {}	//	Устанавливается, когда регистр свободен

	return UDR0;
}
//---------------------------------------------------------------------------------
